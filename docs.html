<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
    <link rel="stylesheet" href="./style.css">

    <!-- fontawesome for icons -->
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
        integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
    <link rel="stylesheet" href="./docs.css">

    <title>CPU Scheduling Simulator</title>
</head>

<body>
    <section class="sub-header">
        <nav>
            <a href="index.html">CPU Simulator</a>
            <div class="nav-links" id="navLinks">
                <i class="fas fa-window-close" onclick="hideMenu()"></i>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="docs.html">Docs</a></li>
                    <li><a href="/Simulator/simulator.html">Simulator</a></li>
                    <li><a href="about.html">About</a></li>
                </ul>
            </div>
            <i class="fas fa-bars" onclick="showMenu()"></i>
        </nav>
        <h1>Documentation</h1>
    </section>


    <!-- Question Section -->
    <section class="container_docs">
        <h2>What is CPU Scheduling?</h2>
        <p>Think of the CPU as a pizza oven and processes as pizzas waiting to bake. 
        The CPU scheduler is the shopkeeper deciding which pizza goes in next. If one
         pizza takes too long, another ready pizza gets baked to keep things moving. The
          goal is to ensure the oven (CPU) never sits idle. Everyone eventually gets their 
          pizza, and the system runs smoothly! üçïüíª
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h2>Why CPU Scheduling?</h2>
        <p>In simple terms, processes need both CPU and I/O time. In single-task systems like
             MS-DOS, the CPU sits idle while waiting for I/O. But in multitasking systems, one
             process uses the CPU while another waits for I/O. This smart juggling of tasks
             is achieved through process scheduling.<br><br>
            <strong>Objectives of Process Scheduling Algorithm</strong>
            <li>Keep the CPU busy as much as possible.</li>
            <li>Distribute CPU time fairly among processes.</li>
            <li>Maximize throughput (more processes completed per unit time).</li>
            <li>Minimize turnaround time (total time for a process to finish).</li>
            <li>Minimize waiting time (time spent in the ready queue).</li>
            <li>Minimize response time (time to produce the first output).</li>

        </p>
    </section>

    <section class="container_docs special" data-aos="zoom-in-up">
        <h2>Important CPU scheduling Terminologies</h2>
        <li><strong>Burst Time/Execution Time:</strong> It is a time required by the process to complete execution. It
            is also called running time.</li>
        <li><strong>Arrival Time:</strong> when a process enters in a ready state</li>
        <li><strong>Finish Time:</strong> when process complete and exit from a system</li>
        <li><strong>Multiprogramming:</strong> A number of programs which can be present in memory at the same time.
        </li>
        <li><strong>Jobs:</strong> It is a type of program without any kind of user interaction.</li>
        <li><strong>User:</strong> It is a kind of program having user interaction.</li>
        <li><strong>Process:</strong> It is the reference that is used for both job and user.</li>
        <li><strong>CPU/IO burst cycle:</strong> Characterizes process execution, which alternates between CPU and I/O
            activity. CPU times are shorter than the time of I/O.</li>

        </p>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h2>Types of CPU Scheduling</h2>
        <p>There is mainly two major types of CPU Scheduling which is listed below.There is sub-types of this algorithm
            also. we have discussed all algorithm in details below. </p>
        <li>Preemptive Algorithm</li>
        <li>Non Preemptive Algorithm</li>
        <br>

        <p><strong class="bold">Preemptive Scheduling</strong><br>
            In preemptive scheduling, tasks are given priorities. If a 
            high-priority task arrives while a lower-priority task is 
            running, the lower-priority task is paused. The high-priority 
            task runs first, and the paused task continues once the 
            high-priority task is done.<br>
            <br>
            <strong class="bold">Non-Preemptive Scheduling</strong><br>
            In non-preemptive scheduling, once a process gets the CPU, it 
            keeps it until it either finishes or voluntarily gives it up 
            (like switching tasks). This method works on all hardware platforms
             because, unlike preemptive scheduling, it doesn‚Äôt require special 
             hardware like a timer.
         </p>
    </section>


    <section class="container_docs" data-aos="zoom-in-up">
        <h2>Types of CPU scheduling Algorithm</h2>
        <p>There are mainly six types of process scheduling algorithm</p>
        <li>First Come First Serve (FCFS)</li>
        <li>Shortest-Job-First (SJF) </li>
        <li>Shortest Remaining Time</li>
        <li>Priority Scheduling</li>
        <li>Round Robin Scheduling</li>
        <li>Multilevel Queue Scheduling</li>
        <br>
    </section>


    <!-- FCFS -->
    <section class="container_docs" data-aos="zoom-in-up">
        <h2>First Come First Serve</h2>
        <p>FCFS is the simplest CPU scheduling algorithm. 
            Processes are served in the order they request the CPU,
             like a "first-come, first-served" line. It works using a FIFO 
             (First In, First Out) queue.<br><br>

            When a process enters the queue, its Process Control Block (PCB) 
            is added to the end. When the CPU is free, it goes to the process 
            at the front of the queue.
        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. It is simple and easy to understand.<br></p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. The process with less execution time suffer i.e. waiting time is often quite long.<br><br>
            2. Favors CPU Bound process then I/O bound process.<br><br>
            3. FCFS algorithm is particularly troublesome for time-sharing systems, where it is important that each user
            get a share of the CPU at regular intervals.</p>
        <button class="btn_1" onclick="gotoFCFS();">Go to FCFS</button>
        <br>
    </section>

    <!-- SRTF -->
    <section class="container_docs" data-aos="zoom-in-up">
        <h2>Shortest Remaining Time</h2>
        <p>The full form of SRT is Shortest remaining time. It is also known as SJF preemptive scheduling. In this
            method, the process will be allocated to the task, which is closest to its completion. This method prevents
            a newer ready state process from holding the completion of an older process.<br></p>

        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. The main advantage of the SRTF algorithm is that it makes the processing of the jobs faster than the SJF
            algorithm, mentioned it‚Äôs overhead charges are not counted.</p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. In SRTF, the context switching is done a lot more times than in SJN due to more consumption of the CPU's
            valuable time for processing. The consumed time of CPU then adds up to its processing time and which then
            diminishes the advantage of fast processing of this algorithm.<br></p>
        <button class="btn_1" onclick="gotoSRTF();">Go to SRTF</button>
        <br>
    </section>

    <!-- Priority -->
    <section class="container_docs" data-aos="zoom-in-up">
        <h2>Priority Based Scheduling</h2>
        <p>Priority scheduling is a method of scheduling processes based on priority. In this method, the scheduler
            selects the tasks to work as per the priority.<br><br>
            Priority scheduling also helps OS to involve priority assignments. The processes with higher priority should
            be carried out first, whereas jobs with equal priorities are carried out on a round-robin or FCFS basis.
            Priority can be decided based on memory requirements, time requirements, etc.<br><br>
        </p>
        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. This provides a good mechanism where the relative importance of each process maybe precisely defined.<br>
        </p>
        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. If high priority processes use up a lot of CPU time, lower priority processes may starve and be postponed
            indefinitely.The situation where a process never gets scheduled to run is called starvation<br><br>
            2. Another problem is deciding which process gets which priority level assigned to it..<br></p>
        <button class="btn_1" onclick="gotoPriority();">Go to Priority</button>
        <br>
    </section>

    <!-- Round Robin -->
    <section class="container_docs" data-aos="zoom-in-up">
        <h2>Round-Robin Scheduling</h2>
        <p>Round Robin is one of the oldest and simplest scheduling algorithms.
            It works like taking turns‚Äîeach process gets an equal share of CPU
            time in a cycle. This method is commonly used in multitasking and
            ensures that no process is left waiting forever (starvation-free execution).<br><br></p>

        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. Every process gets an equal share of the CPU.<br><br>
            2. RR is cyclic in nature, so there is no starvation.</p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. Setting the quantum too short, increases the overhead and lowers the CPU efficiency, but setting it too
            long may cause poor response to short processes.<br><br>
            2. Average waiting time under the RR policy is often long.<br>
        </p>
        <button class="btn_1" onclick="gotoWorking();">Go to RR</button>
        <br>
    </section>

    <!-- SJF -->
    <section class="container_docs" data-aos="zoom-in-up">
        <h2>Shortest Job First</h2>
        <p>SJF is a scheduling algorithm where the process with the shortest
             execution time is selected to run next. It can be either preemptive
              or non-preemptive. This method helps reduce the average waiting
               time for other processes waiting to execute.<br></p>

        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. Shortest jobs are favored.<br><br>
            2. It is provably optimal, in that it gives the minimum average waiting time for a given set of processes.
        </p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. SJF may cause starvation, if shorter processes keep coming. This problem is solved by aging..<br><br>
            2. It cannot be implemented at the level of short term CPU scheduling.<br></p>

        <button class="btn_1" onclick="gotoSJF();">Go to SJF</button>
        <br>
    </section>

    <!--Footer Section  -->
    <section class="footer">
        <div class="icons">
            <a href="#"><i class="fab fa-instagram"></i></a>
            <a href="https://github.com/Sri-Mayur"><i class="fab fa-github"></i></a>
            <a href="https://www.linkedin.com/in/ayushi-varshney-9ba868250/"><i class="fab fa-linkedin"></i></a>
        </div>

        <p>Made With <i class="far fa-heart"></i> by Once in Blue Moon </p>
        
    </section>


    <!--JavaScript  -->
    <script>
        var navLinks = document.getElementById("navLinks");
        function showMenu() {
            navLinks.style.right = "0";
        }

        function hideMenu() {
            navLinks.style.right = "-200px";
        }

        function gotoSimulator() {
            location.href = ("/Simulator/simulator.html");
        }

        function gotoFCFS() {
            location.href = ("./Algorithm/Algo.html");
        }

        function gotoSRTF() {
            location.href = ("./Algorithm/Algo.html");
        }

        function gotoPriority() {
            location.href = ("./Algorithm/Algo.html");
            
        }

        function gotoSJF() {
            location.href = ("./Algorithm/Algo.html");
        }

        function gotoWorking() {
            location.href = ("./Algorithm/Algo.html");
        }

    </script>


    <!-- For the animation -->
    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
    <script>
        AOS.init({
            offset: 200, // offset (in px) from the original trigger point
            duration: 800
        });
    </script>
</body>

</html>